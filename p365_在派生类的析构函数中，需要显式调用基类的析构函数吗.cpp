/*
在派生类的析构函数中，需要显式调用基类的析构函数吗？
	这道题仍旧考查对析构函数的认识。因为 C++ 语言中类的析构函数往往涉及内存资源
的清理和释放，稍有不慎就有可能造成令人头疼的内存泄露问题，所以析构函数对于一个类的编写尤其重要。
对于析构函数的认识和理解，自然也就反映了我们的 C++ 语言功力到底有多深。
	回到问题本身，永远不需要显式调用析构函数，在派生类的析构函数中，自然也不需要调用基类的析构
函数。并且基类的析构函数是在派生类的成员对象被析构之后调用的。例如：
*/
// 成员对象的类
class Member
{
public:
	~Member();
	// ...
};
// 基类
class Base
{
public:
	virtual ~Base(); // 基类的虚析构函数
	// ...
};
// 派生类
class Derived : public Base
{
public:
	~Derived(); // 派生类的析构函数
	// ...
private:
	Member m_Member;
};
// 定义派生类的析构函数
Derived::~Derived()
{
	// 先析构成员对象，然后析构基类
	// 编译器自动调用 m_Member.~Member()
	// 编译器自动调用 Base::~Base()
}












