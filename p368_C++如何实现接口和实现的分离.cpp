/*
在 C++ 语言中，如何实现接口和实现的分离？
	在C++语言中，接口是一个程序最有价值的资源。设计良好的接口，可以降低整个系统的
耦合性，提高系统的内聚，从而达到面向对象"高内聚，低耦合"的设计目的。同时可以让类更易于使用，
更具可维护性。但是，接口的设计往往比用一堆类来实现这个接口更费时间。既然接口如此有价值，它们应该被
保护起来，以免因为数据结构和其他实现的改变而被破坏。因此，应该将接口和具体的实现分离，而在 C++语言中，
我们是通过抽象基类(abstract base class)来实现接口和实现相分离的。
	在设计层次上，抽象基类表达的是一种抽象概念。例如，我们说"动物都会动"，这里的"动物"并不是
特指某一种动物，也不是某一个动物，而是表达的一种抽象概念。因此这里的"动物"就是抽象基类。
在 C++ 语言中，我们用带有一个或者多个纯虚成员函数的类来表示一个抽象基类。例如：
*/
// 动物抽象基类
class Animal
{
public:
	// 使用纯虚函数表示接口
	virtual void Move() = 0; // = 0 表示这是一个纯虚成员函数
};

/*
	在Animal 类中，我们使用了一个纯虚函数 Move() 来表达这个抽象基类的接口。因为抽象
基类只是用来表达"接口"这个抽象概念的，带有纯虚函数，所以它并不能实例化，也就是说，不能
创建某个 Animal 类型的对象。要创建某个具体的动物，必须从抽象基类派生具体的派生类，实现
抽象基类中的纯虚成员函数，也就是将接口逐个实现。
*/
// 从抽象基类派生新的类，实现接口
class Bird : public Animal
{
public:
	// 实现抽象基类的纯虚成员函数，也就是实现接口
	virtual void Move()
	{
		cout<<"鸟儿飞"<<endl;
	}
};

// 从抽象基类派生另外一个类，接口的第二种实现
class Horse : public Animal
{
public:
	// 实现抽象基类的纯虚函数
	virtual void Move()
	{
		cout<<"马儿跑"<<endl;
	}
};

// ...
// 创建保存具体实现对象的容器
// 为了使用动态绑定，避免对象的释放，这里使用了智能指针
vector<shared_ptr<Animal>> vecAnimal;
// 创建实现类的具体对象，并保存到容器中
vecAnimal.push_back(shared_ptr<Animal>(new Bird));
vecAnimal.push_back(shared_ptr<Animal>(new Horse));
// 访问容器中的实现类的对象
for_each(vecAnimal.begin(), vecAnimal.end(), 
	[](shared_ptr<Animal> spAnimal)
	{
		// 调用抽象类提供的接口
		// 在运行时将根据动态绑定原则，调用具体的实现类对接口的实现
		spAnimal->Move();
	});


/*
	在这里，使用抽象基类 Animal 类来表达接口，用从抽象基类 Animal 类派生的 Bird 类和 Horse
类来表达对接口的不同实现。这样，就可以将接口在抽象基类中固定下来，同时又可以在实现类中灵活地
修改接口的实现。例如，如果有一天这匹马变成了会飞的马，就可以将 Horse 类的实现修改如下：
*/
// 修改实现类的具体实现，变成会飞的马
class Horse : public Animal
{
public:
	// 修改接口的实现
	virtual void Move()
	{
		cout<<"马儿飞"<<endl;
	}
};

























